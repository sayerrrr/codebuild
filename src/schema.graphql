### This file was generated by Nexus Schema
### Do not make changes to this file directly


input AttachCategoriesInput {
  requestedCategories: [String]!
}

type AuthPayload {
  token: String!
  user: User!
}

type BatchCount {
  count: Int!
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolUpdateInput {
  set: Boolean
}

type Business {
  address: String
  approved: Boolean
  coverUrl: String
  createdAt: DateTime
  creditAmount: Int
  creditScore: Int
  description: String
  email: String
  externalLinks: [String]
  handle: String!
  id: String!
  logoUrl: String
  name: String!
  offerings: [Offering]
  ownerId: String!
  phoneNumber: String
  socialLinks: [String]
  tagline: String
  updatedAt: DateTime
}

input BusinessListRelationFilter {
  every: BusinessWhereInput
  none: BusinessWhereInput
  some: BusinessWhereInput
}

input BusinessUpdateInput {
  address: String
  approved: Boolean
  coverUrl: String
  creditAmount: Int
  creditScore: Int
  description: String
  email: String
  externalLinks: [String]
  handle: String
  logoUrl: String
  name: String
  phoneNumber: String
  socialLinks: [String]
  tagline: String
}

input BusinessUpdateManyMutationInput {
  creditAmount: IntUpdateInput
  creditScore: IntUpdateInput
  isDisabled: BoolUpdateInput
}

input BusinessWhereInput {
  AND: [BusinessWhereInput]
  NOT: [BusinessWhereInput]
  OR: [BusinessWhereInput]
  address: StringFilter
  approved: BoolFilter
  coverUrl: StringFilter
  createdAt: DateTimeFilter
  creditAmount: IntFilter
  creditScore: IntFilter
  description: StringFilter
  email: StringFilter
  handle: StringFilter
  id: StringFilter
  isDisabled: BoolFilter
  name: StringFilter
  ownerId: StringFilter
  phoneNumber: StringFilter
  tagline: StringFilter
  updatedAt: DateTimeFilter
}

input CategoryUpdateInput {
  category: String
}

input CategoryWhereInput {
  category: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  updatedAt: DateTimeFilter
}

input CreateBusinessInput {
  address: String
  coverUrl: String
  creditAmount: Int
  creditScore: Int
  description: String
  email: String
  externalLinks: [String]
  handle: String!
  logoUrl: String
  name: String!
  ownerId: String!
  phoneNumber: String
  socialLinks: [String]
  tagline: String
}

input CreateBusinessWithOfferingsInput {
  business: CreateBusinessInput!
  offerings: [CreateOfferingWithoutBusinessInput]
}

input CreateCategoryInput {
  category: String
}

input CreateOfferingInput {
  address: String
  businessId: String!
  categoryId: String
  cost: Int!
  description: String
  imageUrl: String
  title: String
  videoUrl: String
}

input CreateOfferingWithoutBusinessInput {
  address: String
  categoryId: String
  cost: Int!
  description: String
  imageUrl: String
  title: String
  videoUrl: String
}

input CreateOrderInput {
  note: String!
  offeringId: String!
  quantity: Int!
}

input CreateTransactionInput {
  amount: Decimal!
  recipientId: String!
  senderId: String!
}

scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  notIn: [DateTime]
}

input DateTimeUpdateInput {
  set: DateTime
}

"""Decimal custom scalar type"""
scalar Decimal

input DecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalFilter
  notIn: [Decimal]
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input EnumRoleFilter {
  equals: Role
  in: [Role]
  not: NestedEnumRoleFilter
  notIn: [Role]
}

input EnumStateFieldUpdateOperationsInput {
  set: OrderState
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

input IntUpdateInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

type Mutation {
  attachExistingCategoriesToOffering(data: AttachCategoriesInput!, id: ID!): Offering
  attachExistingCategoriesToUser(data: AttachCategoriesInput!, id: ID!): User
  createBusiness(data: CreateBusinessInput): Business!
  createBusinessWithOfferings(data: CreateBusinessWithOfferingsInput): Business!
  createCategory(data: CreateCategoryInput): OfferingCategory!
  createOffering(data: CreateOfferingInput): Offering!
  createOrder(data: CreateOrderInput): Order!
  createTransaction(data: CreateTransactionInput): Transaction!
  deleteManyCategory(where: CategoryWhereInput!): BatchCount!
  deleteOneCategory(id: ID!): OfferingCategory
  disableBusiness(id: ID!): Business!
  disableOffering(id: ID!): Offering
  disableUser(id: ID!): User!
  issueOrderRefund(id: ID!): Order!
  loginUser(email: String!, password: String!): AuthPayload!
  registerUser(data: UserCreateInput!): AuthPayload!
  requestReset(email: String!): User
  resetPassword(confirmPassword: String!, email: String!, password: String!, resetPasswordToken: String!): AuthPayload!
  signS3(fileName: String!): S3SignedPath!
  updateBusiness(data: BusinessUpdateInput!, id: ID!): Business!
  updateManyBusiness(data: BusinessUpdateManyMutationInput!, where: BusinessWhereInput): BatchCount!
  updateManyCategory(data: CategoryUpdateInput!, where: CategoryWhereInput): BatchCount
  updateManyUser(data: UserUpdateManyMutationInput, where: UserWhereInput): BatchCount
  updateOffering(data: UpdateOfferingInput, id: ID!): Offering
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: DateTimeFilter
  notIn: [DateTime]
}

input NestedDecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalFilter
  notIn: [Decimal]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role]
  notIn: [Role]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

type Offering {
  address: String
  businessId: String!
  categories: [OfferingCategory]
  cost: Int!
  createdAt: DateTime!
  description: String
  id: ID!
  imageUrl: String
  title: String
  updatedAt: DateTime!
  videoUrl: String
}

type OfferingCategory {
  category: String!
  createdAt: DateTime!
  id: ID!
}

input OfferingCategoryListRelationFilter {
  every: CategoryWhereInput
  none: CategoryWhereInput
  some: CategoryWhereInput
}

input OfferingListRelationFilter {
  every: OfferingWhereInput
  none: OfferingWhereInput
  some: OfferingWhereInput
}

input OfferingWhereInput {
  AND: [OfferingWhereInput]
  NOT: [OfferingWhereInput]
  OR: [OfferingWhereInput]
  address: StringFilter
  businessId: StringFilter
  categories: OfferingCategoryListRelationFilter
  cost: DecimalFilter
  createdAt: DateTimeFilter
  description: StringFilter
  id: StringFilter
  isDisabled: BoolFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

type Order {
  amount: Decimal!
  createdAt: DateTime!
  id: String!
  note: String!
  offeringId: String!
  quantity: Int!
  state: OrderState!
  transactionId: String!
  updatedAt: DateTime!
}

enum OrderState {
  PAID
  PENDING
  REFUNDED
}

input OrderStateFilter {
  equals: OrderState
}

input OrderWhereInput {
  AND: [OrderWhereInput]
  NOT: [OrderWhereInput]
  OR: [OrderWhereInput]
  amount: DecimalFilter
  createdAt: DateTimeFilter
  id: StringFilter
  note: StringFilter
  offering: OfferingWhereInput
  offeringId: StringFilter
  quantity: IntFilter
  state: OrderStateFilter
  transaction: TransactionWhereInput
  transactionId: StringFilter
}

input OrderWhereUniqueInput {
  id: String
}

type Query {
  allBusinessTransactions(id: ID!, skip: Int, take: Int): [Transaction]
  allOrders(skip: Int, take: Int, where: OrderWhereInput): [Order]
  allTransactions(skip: Int, take: Int, where: TransactionWhereInput): [Transaction]
  businessBalance(id: ID!): Decimal!
  countAllBusiness(where: BusinessWhereInput): Int
  countAllCategory(where: CategoryWhereInput): Int
  countAllOffering(where: OfferingWhereInput): Int
  countAllOrders(where: OrderWhereInput): Int!
  countAllTransactions(where: TransactionWhereInput): Int
  countAllUsers(where: UserWhereInput): Int
  findAllUsers(skip: Int, take: Int, where: UserWhereInput): [User!]!
  findByBusiness(id: ID!): [Offering]
  findManyBusiness(skip: Int, take: Int, where: BusinessWhereInput): [Business!]!
  findManyCategory(skip: Int, take: Int, where: CategoryWhereInput): [OfferingCategory]
  findManyOffering(skip: Int, take: Int, where: OfferingWhereInput): [Offering!]!
  findOneBusiness(id: ID!): Business
  findOneCategory(id: ID!): OfferingCategory
  findOneOffering(id: ID!): Offering
  findOneOrder(id: ID!): Order!
  findUserByEmail(email: String!): User
  findUserById(id: ID!): User
  isEmailUnique(email: String!): Boolean
  isHandleUnique(handle: String!): Boolean!
  isInviteCodeValid(code: String!): Boolean
  me: User
}

enum Role {
  ADMIN
  USER
}

type S3SignedPath {
  url: String!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

type Transaction {
  amount: Decimal!
  createdAt: DateTime
  id: ID!
  recipientId: String!
  senderId: String!
}

input TransactionWhereInput {
  AND: [TransactionWhereInput]
  NOT: [TransactionWhereInput]
  OR: [TransactionWhereInput]
  amount: DecimalFilter
  createdAt: DateTimeFilter
  id: StringFilter
  offering: OfferingWhereInput
  offeringId: StringFilter
  recipient: BusinessWhereInput
  recipientId: StringFilter
  sender: BusinessWhereInput
  senderId: StringFilter
}

input TransactionWhereUniqueInput {
  id: String
}

input UpdateOfferingInput {
  address: String
  cost: Int
  description: String
  imageUrl: String
  title: String
  videoUrl: String
}

type User {
  avatarUrl: String
  business: [Business]
  createdAt: DateTime!
  email: String!
  firstName: String
  id: String!
  isAdmin: Boolean!
  isDisabled: Boolean!
  isEmailValidated: Boolean!
  lastLogin: DateTime
  lastName: String
  password: String!
  requestedCategories: [String]
  resetPasswordExpiry: DateTime
  resetPasswordToken: String
  role: Role!
  updatedAt: DateTime!
  validateEmailToken: String!
}

input UserCreateInput {
  email: String!
  firstName: String!
  lastName: String!
  password: String!
}

input UserUpdateInput {
  avatarUrl: String
  dateResetPasswordRequest: DateTime
  email: String
  firstName: String
  handle: String
  isEmailValidated: Boolean
  lastLogin: DateTime
  lastName: String
  password: String
  resetPasswordToken: String
  role: Role
  updatedAt: DateTime
}

input UserUpdateManyMutationInput {
  isAdmin: BoolUpdateInput
  isDisabled: BoolUpdateInput
  lastLogin: DateTimeUpdateInput
  role: EnumRoleFieldUpdateOperationsInput
}

input UserWhereInput {
  AND: [UserWhereInput]
  NOT: [UserWhereInput]
  OR: [UserWhereInput]
  business: BusinessListRelationFilter
  createdAt: DateTimeFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  isAdmin: BoolFilter
  isDisabled: BoolFilter
  isEmailValidated: BoolFilter
  lastLogin: DateTimeFilter
  lastName: StringFilter
  password: StringFilter
  role: EnumRoleFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
}
